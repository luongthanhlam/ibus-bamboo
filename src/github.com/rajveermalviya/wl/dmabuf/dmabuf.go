// generated by wl-scanner
// https://github.com/rajveermalviya/wl-scanner
// from: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml
// on 2021-03-10 03:11:08 +0530

package dmabuf

import (
	"sync"

	"github.com/rajveermalviya/wl"
)

type ZwpLinuxDmabufFormatEvent struct {
	Format uint32
}

type ZwpLinuxDmabufFormatHandler interface {
	HandleZwpLinuxDmabufFormat(ZwpLinuxDmabufFormatEvent)
}

func (p *ZwpLinuxDmabuf) AddFormatHandler(h ZwpLinuxDmabufFormatHandler) {
	if h == nil {
		return
	}

	p.mu.Lock()
	p.formatHandlers = append(p.formatHandlers, h)
	p.mu.Unlock()
}

func (p *ZwpLinuxDmabuf) RemoveFormatHandler(h ZwpLinuxDmabufFormatHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.formatHandlers {
		if e == h {
			p.formatHandlers = append(p.formatHandlers[:i], p.formatHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxDmabufModifierEvent struct {
	Format     uint32
	ModifierHi uint32
	ModifierLo uint32
}

type ZwpLinuxDmabufModifierHandler interface {
	HandleZwpLinuxDmabufModifier(ZwpLinuxDmabufModifierEvent)
}

func (p *ZwpLinuxDmabuf) AddModifierHandler(h ZwpLinuxDmabufModifierHandler) {
	if h == nil {
		return
	}

	p.mu.Lock()
	p.modifierHandlers = append(p.modifierHandlers, h)
	p.mu.Unlock()
}

func (p *ZwpLinuxDmabuf) RemoveModifierHandler(h ZwpLinuxDmabufModifierHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.modifierHandlers {
		if e == h {
			p.modifierHandlers = append(p.modifierHandlers[:i], p.modifierHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpLinuxDmabuf) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		p.mu.RLock()
		if len(p.formatHandlers) > 0 {
			p.mu.RUnlock()

			ev := ZwpLinuxDmabufFormatEvent{}
			ev.Format = event.Uint32()

			p.mu.RLock()
			for _, h := range p.formatHandlers {
				p.mu.RUnlock()

				h.HandleZwpLinuxDmabufFormat(ev)

				p.mu.RLock()
			}
			p.mu.RUnlock()
		} else {
			p.mu.RUnlock()
		}
	case 1:
		p.mu.RLock()
		if len(p.modifierHandlers) > 0 {
			p.mu.RUnlock()

			ev := ZwpLinuxDmabufModifierEvent{}
			ev.Format = event.Uint32()
			ev.ModifierHi = event.Uint32()
			ev.ModifierLo = event.Uint32()

			p.mu.RLock()
			for _, h := range p.modifierHandlers {
				p.mu.RUnlock()

				h.HandleZwpLinuxDmabufModifier(ev)

				p.mu.RLock()
			}
			p.mu.RUnlock()
		} else {
			p.mu.RUnlock()
		}
	}
}

type ZwpLinuxDmabuf struct {
	wl.BaseProxy
	mu               sync.RWMutex
	formatHandlers   []ZwpLinuxDmabufFormatHandler
	modifierHandlers []ZwpLinuxDmabufModifierHandler
}

func NewZwpLinuxDmabuf(ctx *wl.Context) *ZwpLinuxDmabuf {
	ret := &ZwpLinuxDmabuf{}
	ctx.Register(ret)
	return ret
}

// Destroy will unbind the factory.
//
//
// Objects created through this interface, especially wl_buffers, will
// remain valid.
//
func (p *ZwpLinuxDmabuf) Destroy() error {
	return p.Context().SendRequest(p, 0)
}

// CreateParams will create a temporary object for buffer parameters.
//
//
// This temporary object is used to collect multiple dmabuf handles into
// a single batch to create a wl_buffer. It can only be used once and
// should be destroyed after a 'created' or 'failed' event has been
// received.
//
func (p *ZwpLinuxDmabuf) CreateParams() (*ZwpLinuxBufferParams, error) {
	ret := NewZwpLinuxBufferParams(p.Context())
	return ret, p.Context().SendRequest(p, 1, wl.Proxy(ret))
}

type ZwpLinuxBufferParamsCreatedEvent struct {
	Buffer *wl.Buffer
}

type ZwpLinuxBufferParamsCreatedHandler interface {
	HandleZwpLinuxBufferParamsCreated(ZwpLinuxBufferParamsCreatedEvent)
}

func (p *ZwpLinuxBufferParams) AddCreatedHandler(h ZwpLinuxBufferParamsCreatedHandler) {
	if h == nil {
		return
	}

	p.mu.Lock()
	p.createdHandlers = append(p.createdHandlers, h)
	p.mu.Unlock()
}

func (p *ZwpLinuxBufferParams) RemoveCreatedHandler(h ZwpLinuxBufferParamsCreatedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createdHandlers {
		if e == h {
			p.createdHandlers = append(p.createdHandlers[:i], p.createdHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxBufferParamsFailedEvent struct{}

type ZwpLinuxBufferParamsFailedHandler interface {
	HandleZwpLinuxBufferParamsFailed(ZwpLinuxBufferParamsFailedEvent)
}

func (p *ZwpLinuxBufferParams) AddFailedHandler(h ZwpLinuxBufferParamsFailedHandler) {
	if h == nil {
		return
	}

	p.mu.Lock()
	p.failedHandlers = append(p.failedHandlers, h)
	p.mu.Unlock()
}

func (p *ZwpLinuxBufferParams) RemoveFailedHandler(h ZwpLinuxBufferParamsFailedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.failedHandlers {
		if e == h {
			p.failedHandlers = append(p.failedHandlers[:i], p.failedHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpLinuxBufferParams) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		p.mu.RLock()
		if len(p.createdHandlers) > 0 {
			p.mu.RUnlock()

			ev := ZwpLinuxBufferParamsCreatedEvent{}
			ev.Buffer = event.Proxy(p.Context()).(*wl.Buffer)

			p.mu.RLock()
			for _, h := range p.createdHandlers {
				p.mu.RUnlock()

				h.HandleZwpLinuxBufferParamsCreated(ev)

				p.mu.RLock()
			}
			p.mu.RUnlock()
		} else {
			p.mu.RUnlock()
		}
	case 1:
		p.mu.RLock()
		if len(p.failedHandlers) > 0 {
			p.mu.RUnlock()

			ev := ZwpLinuxBufferParamsFailedEvent{}

			p.mu.RLock()
			for _, h := range p.failedHandlers {
				p.mu.RUnlock()

				h.HandleZwpLinuxBufferParamsFailed(ev)

				p.mu.RLock()
			}
			p.mu.RUnlock()
		} else {
			p.mu.RUnlock()
		}
	}
}

type ZwpLinuxBufferParams struct {
	wl.BaseProxy
	mu              sync.RWMutex
	createdHandlers []ZwpLinuxBufferParamsCreatedHandler
	failedHandlers  []ZwpLinuxBufferParamsFailedHandler
}

func NewZwpLinuxBufferParams(ctx *wl.Context) *ZwpLinuxBufferParams {
	ret := &ZwpLinuxBufferParams{}
	ctx.Register(ret)
	return ret
}

// Destroy will delete this object, used or not.
//
//
// Cleans up the temporary data sent to the server for dmabuf-based
// wl_buffer creation.
//
func (p *ZwpLinuxBufferParams) Destroy() error {
	return p.Context().SendRequest(p, 0)
}

// Add will add a dmabuf to the temporary set.
//
//
// This request adds one dmabuf to the set in this
// zwp_linux_buffer_params_v1.
//
// The 64-bit unsigned value combined from modifier_hi and modifier_lo
// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
// fb modifier, which is defined in drm_mode.h of Linux UAPI.
// This is an opaque token. Drivers use this token to express tiling,
// compression, etc. driver-specific modifications to the base format
// defined by the DRM fourcc code.
//
// Warning: It should be an error if the format/modifier pair was not
// advertised with the modifier event. This is not enforced yet because
// some implementations always accept DRM_FORMAT_MOD_INVALID. Also
// version 2 of this protocol does not have the modifier event.
//
// This request raises the PLANE_IDX error if plane_idx is too large.
// The error PLANE_SET is raised if attempting to set a plane that
// was already set.
//
func (p *ZwpLinuxBufferParams) Add(fd uintptr, plane_idx, offset, stride, modifier_hi, modifier_lo uint32) error {
	return p.Context().SendRequest(p, 1, fd, plane_idx, offset, stride, modifier_hi, modifier_lo)
}

// Create will create a wl_buffer from the given dmabufs.
//
//
// This asks for creation of a wl_buffer from the added dmabuf
// buffers. The wl_buffer is not created immediately but returned via
// the 'created' event if the dmabuf sharing succeeds. The sharing
// may fail at runtime for reasons a client cannot predict, in
// which case the 'failed' event is triggered.
//
// The 'format' argument is a DRM_FORMAT code, as defined by the
// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
// authoritative source on how the format codes should work.
//
// The 'flags' is a bitfield of the flags defined in enum "flags".
// 'y_invert' means the that the image needs to be y-flipped.
//
// Flag 'interlaced' means that the frame in the buffer is not
// progressive as usual, but interlaced. An interlaced buffer as
// supported here must always contain both top and bottom fields.
// The top field always begins on the first pixel row. The temporal
// ordering between the two fields is top field first, unless
// 'bottom_first' is specified. It is undefined whether 'bottom_first'
// is ignored if 'interlaced' is not set.
//
// This protocol does not convey any information about field rate,
// duration, or timing, other than the relative ordering between the
// two fields in one buffer. A compositor may have to estimate the
// intended field rate from the incoming buffer rate. It is undefined
// whether the time of receiving wl_surface.commit with a new buffer
// attached, applying the wl_surface state, wl_surface.frame callback
// trigger, presentation, or any other point in the compositor cycle
// is used to measure the frame or field times. There is no support
// for detecting missed or late frames/fields/buffers either, and
// there is no support whatsoever for cooperating with interlaced
// compositor output.
//
// The composited image quality resulting from the use of interlaced
// buffers is explicitly undefined. A compositor may use elaborate
// hardware features or software to deinterlace and create progressive
// output frames from a sequence of interlaced input buffers, or it
// may produce substandard image quality. However, compositors that
// cannot guarantee reasonable image quality in all cases are recommended
// to just reject all interlaced buffers.
//
// Any argument errors, including non-positive width or height,
// mismatch between the number of planes and the format, bad
// format, bad offset or stride, may be indicated by fatal protocol
// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
// OUT_OF_BOUNDS.
//
// Dmabuf import errors in the server that are not obvious client
// bugs are returned via the 'failed' event as non-fatal. This
// allows attempting dmabuf sharing and falling back in the client
// if it fails.
//
// This request can be sent only once in the object's lifetime, after
// which the only legal request is destroy. This object should be
// destroyed after issuing a 'create' request. Attempting to use this
// object after issuing 'create' raises ALREADY_USED protocol error.
//
// It is not mandatory to issue 'create'. If a client wants to
// cancel the buffer creation, it can just destroy this object.
//
func (p *ZwpLinuxBufferParams) Create(width, height int32, format, flags uint32) error {
	return p.Context().SendRequest(p, 2, width, height, format, flags)
}

// CreateImmed will immediately create a wl_buffer from the given dmabufs.
//
//
// This asks for immediate creation of a wl_buffer by importing the
// added dmabufs.
//
// In case of import success, no event is sent from the server, and the
// wl_buffer is ready to be used by the client.
//
// Upon import failure, either of the following may happen, as seen fit
// by the implementation:
// - the client is terminated with one of the following fatal protocol
// errors:
// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
// in case of argument errors such as mismatch between the number
// of planes and the format, bad format, non-positive width or
// height, or bad offset or stride.
// - INVALID_WL_BUFFER, in case the cause for failure is unknown or
// plaform specific.
// - the server creates an invalid wl_buffer, marks it as failed and
// sends a 'failed' event to the client. The result of using this
// invalid wl_buffer as an argument in any request by the client is
// defined by the compositor implementation.
//
// This takes the same arguments as a 'create' request, and obeys the
// same restrictions.
//
func (p *ZwpLinuxBufferParams) CreateImmed(width, height int32, format, flags uint32) (*wl.Buffer, error) {
	ret := wl.NewBuffer(p.Context())
	return ret, p.Context().SendRequest(p, 3, wl.Proxy(ret), width, height, format, flags)
}

const (
	ZwpLinuxBufferParamsErrorAlreadyUsed       = 0
	ZwpLinuxBufferParamsErrorPlaneIDx          = 1
	ZwpLinuxBufferParamsErrorPlaneSet          = 2
	ZwpLinuxBufferParamsErrorIncomplete        = 3
	ZwpLinuxBufferParamsErrorInvalidFormat     = 4
	ZwpLinuxBufferParamsErrorInvalidDimensions = 5
	ZwpLinuxBufferParamsErrorOutOfBounds       = 6
	ZwpLinuxBufferParamsErrorInvalidWlBuffer   = 7
)

const (
	ZwpLinuxBufferParamsFlagsYInvert     = 1
	ZwpLinuxBufferParamsFlagsInterlaced  = 2
	ZwpLinuxBufferParamsFlagsBottomFirst = 4
)
